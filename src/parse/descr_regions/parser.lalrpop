use std::{collections::HashMap, iter::Iterator};

use crate::parse::descr_regions::{Token, Region};

grammar<'source>;

pub Regions = "\n"* <Region+>;

Region: Region =
        <id:Ident> "\n"+
        <legion:("\t" "legion" ":" <Ident> "\n"+)?>
        "\t" <city:Ident> "\n"+
        "\t" <faction:Ident> "\n"+
        "\t" <rebels:Ident> "\n"+
        "\t" <color:(<int> <int> <int>)> "\n"+
        "\t" <hidden_resources:HiddenResources> "\n"+
        "\t" <triumph:int> "\n"+
        "\t" <farming:int> "\n"+
        <religions:Default<("\t" <Religions> "\n"+)>>
    => Region {<>};

HiddenResources = {
    "none" => vec![],
    SepBy<Resource, ",">,
}

Religions: HashMap<String, u32> = Religion+
    => (<>).into_iter().collect();

Religion = Ident int;

Ident: String = {
    ident => (<>).into(),
    "none" => "none".into(),
    "legion" => "legion".into(),
};

Resource: String = {
    ident => (<>).into(),
    "legion" => "legion".into(),
};

Default<T>: T = T? => (<>).unwrap_or_default();

SepBy<T, Sep>: Vec<T> = <mut v:(<T> Sep)*> <e:T?>
    => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    };

extern {
    type Error = ();

    enum Token<'source> {
        "none" => Token::Ident("none"),
        "legion" => Token::Ident("legion"),
        ":" => Token::Colon,
        "," => Token::Comma,
        "\t" => Token::Tab,
        "\n" => Token::Newline,
        ident => Token::Ident(<&'source str>),
        int => Token::Int(<u32>),
    }
}
