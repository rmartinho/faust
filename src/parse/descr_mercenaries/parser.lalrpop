use crate::parse::descr_mercenaries::{Token, Unit, Pool};

grammar<'source>;

pub Pools = "\n"* <Pool+>;

Pool: Pool =
        "pool" <id:Ident> "\n"+
        "regions" <regions:(<Ident> ","?)+> "\n"+
        <units:(<Unit> "\n"+)+>
    => Pool {<>};

Unit: Unit =
        "unit" <id:IdentSpace> ","
        "exp" <exp:int>
        "cost" <cost:int>
        "replenish" <replenish:(<float> "-" <float>)>
        "max" <max:int>
        "initial" <initial:int>
        <restrict:Default<("restrict" <SepBy<Ident, ",">>)>>
    => Unit {<>};

Ident: String = {
    ident => (<>).into(),
    "pool" => "pool".into(),
    "regions" => "regions".into(),
    "unit" => "unit".into(),
    "exp" => "exp".into(),
    "cost" => "cost".into(),
    "replenish" => "replenish".into(),
    "max" => "max".into(),
    "initial" => "initial".into(),
    "restrict" => "restrict".into(),
};
IdentSpace: String = Ident+
    => (<>).into_iter()
        .fold(String::new(), |a, x| a + " " + &x)
        .trim().into();

Default<T>: T = T? => (<>).unwrap_or_default();

SepBy<T, Sep>: Vec<T> = <mut v:(<T> Sep)*> <e:T?>
    => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    };

extern {
    type Location = usize;
    type Error = ();

    enum Token<'source> {
        "pool" => Token::Ident("pool"),
        "regions" => Token::Ident("regions"),
        "unit" => Token::Ident("unit"),
        "exp" => Token::Ident("exp"),
        "cost" => Token::Ident("cost"),
        "replenish" => Token::Ident("replenish"),
        "max" => Token::Ident("max"),
        "initial" => Token::Ident("initial"),
        "restrict" => Token::Ident("restrict"),
        "-" => Token::Hyphen,
        "," => Token::Comma,
        "\n" => Token::Newline,
        ident => Token::Ident(<&'source str>),
        int => Token::Int(<u32>),
        float => Token::Float(<f64>),
    }
}
